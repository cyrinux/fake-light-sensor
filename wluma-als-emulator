#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import getopt
import math
import os
import os.path
import subprocess
import sys
import tempfile
import signal
from datetime import datetime, time
from pathlib import Path
from time import sleep

VERSION = "1.1.0"
FAKE_SENSOR = "/tmp/fake-devices"
LOCKFILE = "wluma-als-emulator.lock"
INPUT = "/dev/video0"
DEFAULT_SLEEP_MODE = "lux"
DEFAULT_SLEEP_TIME = 30
DEFAULT_STRATEGY = "webcam"

# If lux from webcam change too much
# raise probes
WEBCAM_PROBES = 1

WEBCAM_SLEEP_PER_PERIODS = {
    300: [[0, 6], [20, 23]],
    15: [[6, 19]],
}


class WebcamStrategy:
    def __init__(self, config):
        self.config = config
        self.lux = None

        self.capture_command = [
            "ffmpeg",
            "-hide_banner",
            "-loglevel",
            "panic",
            "-i",
            self.config.input,
            "-vframes",
            "1",
        ]

        self.get_sleep_time()

        if self.config.verbose:
            print("Sleep mode: {} will be use".format(self.config.sleep_mode))

    def get_brighness(self, screenshot_cmd):
        f, path = tempfile.mkstemp()
        os.close(f)
        os.remove(path)

        path += ".jpg"
        try:
            subprocess.run([*screenshot_cmd, path], check=True)
        except FileNotFoundError as e:
            raise ("The binary is not found?\n{}".format(e))

        result = None
        with Image.open(path) as im:
            stat = ImageStat.Stat(im)
            r, g, b = stat.rms
            result = math.sqrt(0.241 * (r ** 2) + 0.691 * (g ** 2) + 0.068 * (b ** 2))

        os.remove(path)
        return int(100 * (result / 255))

    def calculate(self):
        results = []
        for _ in range(0, WEBCAM_PROBES):
            results.append(self.get_brighness(self.capture_command))
            sleep(1)
        return int(sum(results) / float(len(results)))

    def get_sleep_time(self):
        self.sleep_time = self.config.sleep_time
        if self.config.sleep_mode == "fixed":
            self.sleep_time = self.config.sleep_time
        elif self.config.sleep_mode == "periods":
            self.sleep_time = self.config.get_sleep_by_periods()
        elif self.config.sleep_mode == "lux" and self.lux:
            # less refresh in the dark
            self.sleep_time = (
                (self.config.sleep_time * 2)
                if self.lux <= 10
                else self.config.sleep_time
            )

            # more refresh if very bright
            self.sleep_time = (
                (self.config.sleep_time * 0.5)
                if self.lux >= 80
                else self.config.sleep_time
            )
        if WEBCAM_PROBES > 1:
            self.sleep_time = self.sleep_time - WEBCAM_PROBES

    def loop(self):
        # get sensor value
        try:
            self.lux = self.calculate()
        except subprocess.CalledProcessError as e:
            raise ("Can't get lux, bad input device?\n{}".format(e))

        self.get_sleep_time()

        if self.config.verbose:
            print("lux={} | waiting {} seconds...".format(self.lux, self.sleep_time))


class TimeStrategy:
    def __init__(self, config):
        self.config = config
        self.lux = None
        self.sleep_time = self.config.sleep_time

    def calculate(self):
        """
        we take current time (say 11:10am), convert to seconds (11*60*60 + 10*60 = 40200),
        and then because midday (43200s) is 100% lux and midnight (0s) is 0% lux,
        change of 1% of lux is (43200 / 100 = 432),
        current time 11am should be (100 - (43200 - 40200) / 432) = 93% of lux
        """
        midday_in_seconds = 43200
        datenow = datetime.now()
        midnight = datetime.combine(datenow.date(), time(0))
        now = datenow - midnight
        now_in_seconds = now.seconds
        # from midnigh to midday lux up
        if now_in_seconds > midday_in_seconds:
            lux = 100 - ((now_in_seconds * 100 / 43200) - 100)
        else:
            # after midday to midnigh lux down
            lux = now_in_seconds * 100 / 43200
        return int(lux)

    def loop(self):
        self.lux = self.calculate()

        if self.config.verbose:
            print("lux={} | waiting {} seconds...".format(self.lux, self.sleep_time))


class FakeSensor:
    def __init__(self, strategy):
        self.config = config
        self.strategy = strategy
        self.create_fake_sensor()
        self.prev_lux = None
        self.lux = None

        # on exit do
        signal.signal(signal.SIGTERM, self.exit_handler)
        signal.signal(signal.SIGINT, self.exit_handler)

        # lock
        if os.path.isfile(self.lockfile()):
            print("{} is already running!".format(os.path.basename(__file__)))
            sys.exit(2)
        Path(self.lockfile()).touch()

    def run(self):
        while True:
            self.strategy.loop()
            if self.strategy.lux != self.prev_lux:
                self.prev_lux = self.strategy.lux
                self.write_lux(self.strategy.lux)

            # wait
            sleep(self.config.sleep_time)

    def lockfile(self):
        return self.config.output_basedir + "/" + LOCKFILE

    def cleanup(self):
        os.remove(self.lockfile())

    def exit_handler(self, signal, frame):
        print("Receive signal {}, shutdown ALS emulator...".format(signal))
        self.cleanup()
        sys.exit(0)

    def create_fake_sensor(self):
        # create fake /sys dir
        Path(self.config.output_basedir).mkdir(parents=True, exist_ok=True)

        als_raw = self.config.output_basedir + "/in_illuminance_raw"
        als_name = self.config.output_basedir + "/name"

        if not os.path.isfile(als_name):
            name = open(als_name, "w")
            name.write("als")
            name.flush()

        if self.config.verbose:
            print("input: {}, output: {}".format(self.config.input, als_raw))

        self.sensor = open(als_raw, "w+")

    def write_lux(self, lux):
        # write sensor value
        self.sensor.seek(0)
        self.sensor.truncate()
        self.sensor.write(str(lux))
        self.sensor.flush()
        os.fsync(self.sensor)


class Config:
    def __init__(self):
        # test params
        try:
            opts, _ = getopt.getopt(
                sys.argv[1:],
                "i:o:s:t:hvV",
                [
                    "input=",
                    "output=",
                    "sleep=",
                    "strategy=",
                    "help",
                    "verbose",
                    "version",
                ],
            )
        except getopt.GetoptError as err:
            print(err)
            self.usage()
            sys.exit(2)

        # default values
        self.input = INPUT
        self.sleep_mode = DEFAULT_SLEEP_MODE
        self.sleep_time = DEFAULT_SLEEP_TIME
        self.strategy = DEFAULT_STRATEGY
        self.verbose = False
        self.output_basedir = (
            os.environ.get("WLUMA_AMBIENT_LIGHT_SENSOR_BASE_PATH", FAKE_SENSOR)
            + "/light-sensor"
        )
        self.strategy = os.environ.get(
            "WLUMA_AMBIENT_LIGHT_SENSOR_EMULATOR_STRATEGY", DEFAULT_STRATEGY
        )

        # get params values
        for opt, arg in opts:
            if opt in ("-v", "--verbose"):
                self.verbose = True
            elif opt in ("-i", "--input"):
                self.input = arg
            elif opt in ("-t", "--strategy"):
                self.strategy = arg
            elif opt in ("-s", "--sleep"):
                self.get_sleep_params(arg)
            elif opt in ("-o", "--output"):
                self.output_basedir = arg
            elif opt in ("-h", "--help"):
                self.usage()
                sys.exit(0)
            elif opt in ("-V", "--version"):
                print("version {}".format(VERSION))
                sys.exit(0)
            else:
                assert False, "unhandled option, see --help"

            if self.strategy == "time":
                self.input = "time based"

    def get_sleep_params(self, arg):
        if arg == "periods":
            self.sleep_mode = "periods"
        elif arg == "lux":
            self.sleep_mode = "lux"
        else:
            try:
                self.sleep_time = int(arg)
                self.sleep_mode = "fixed"
            except:
                self.sleep_time = int(DEFAULT_SLEEP_TIME)
                print(
                    "sleep must be an int or 'lux' or 'periods', default to {} seconds.".format(
                        DEFAULT_SLEEP_TIME
                    )
                )

    def get_sleep_by_periods(self):
        hour = datetime.now().hour
        sleep_time = 30
        for p in WEBCAM_SLEEP_PER_PERIODS:
            for r in WEBCAM_SLEEP_PER_PERIODS[p]:
                if hour in range(r[0], r[1]):
                    sleep_time = p
                    break
        return int(sleep_time)

    def usage(self):
        print(
            """{} [--input=/dev/video0] [--output=/tmp/fake-devicse]
               [--sleep=10/periods] [--strategy=webcam/time] [--verbose] [--version]\n""".format(
                os.path.basename(__file__)
            )
        )

        print(
            "env WLUMA_AMBIENT_LIGHT_SENSOR_EMULATOR_STRATEGY can be use for 'strategy'"
        )
        print(
            "env WLUMA_AMBIENT_LIGHT_SENSOR_BASE_PATH if set will be use as output to play with wluma"
        )


if __name__ == "__main__":

    try:
        config = Config()
        if config.strategy == "time":
            strategy = TimeStrategy(config)
        elif config.strategy == "webcam":
            from PIL import Image, ImageStat

            strategy = WebcamStrategy(config)
        else:
            config.usage()
            sys.exit(1)

        fals = FakeSensor(strategy)
        fals.run()

    except Exception as e:
        print("Got exception, aborting: ", e)
        fals.cleanup()
        sys.exit(3)
