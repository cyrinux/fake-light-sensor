#!/usr/bin/env python3

import getopt
import math
import os
import os.path
import subprocess
import sys
import tempfile
import signal
from datetime import datetime, time
from pathlib import Path
from time import sleep

FAKE_SENSOR = "/tmp/fake-devices"
INPUT = "/dev/video0"
LOCKFILE = "fake-light-sensor.lock"
SLEEP_MODE = "lux"
SLEEP_TIME = 30
STRATEGY = "webcam"

SLEEP_PER_PERIODS = {
    300: [[0, 6], [20, 23]],
    15: [[12, 15]],
}


class WebcamStrategy:
    def __init__(self, config):
        self.config = config
        self.lux = self.prev_lux = None

        self.capture_command = [
            "ffmpeg",
            "-hide_banner",
            "-loglevel",
            "panic",
            "-i",
            config.input,
            "-vframes",
            "1",
        ]

    def calculate(self, screenshot_cmd):
        f, path = tempfile.mkstemp()
        os.close(f)
        os.remove(path)

        path += ".jpg"
        try:
            subprocess.run([*screenshot_cmd, path], check=True)
        except FileNotFoundError as e:
            raise ("The binary is not found?\n{}".format(e))
            sys.exit(1)

        result = None
        with Image.open(path) as im:
            stat = ImageStat.Stat(im)
            r, g, b = stat.rms
            result = math.sqrt(0.241 * (r ** 2) + 0.691 * (g ** 2) + 0.068 * (b ** 2))

        os.remove(path)
        return int(100 * (result / 255))

    def loop(self):
        if self.config.verbose:
            print("Sleep mode: {} will be use".format(self.config.sleep_mode))

        while True:
            # get sensor value
            try:
                self.lux = self.calculate(self.capture_command)
            except subprocess.CalledProcessError as e:
                raise ("Can't get lux, bad input device?\n{}".format(e))
                sys.exit(1)

            if self.lux != self.prev_lux:
                self.prev_lux = self.lux
                self.config.write_lux(self.lux)

            if self.config.sleep_mode == "fixed":
                sleep_time = self.config.sleep_time
            elif self.config.sleep_mode == "periods":
                sleep_time = self.config.get_sleep_by_periods()
            elif self.config.sleep_mode == "lux":
                # less refresh in the dark
                sleep_time = (
                    (self.config.sleep_time * 2)
                    if self.lux <= 10
                    else self.config.sleep_time
                )

                # more refresh if very bright
                sleep_time = (
                    (self.config.sleep_time * 0.5)
                    if self.lux >= 80
                    else self.config.sleep_time
                )

            if self.config.verbose:
                print("lux={} | waiting {} seconds...".format(self.lux, sleep_time))

            # wait
            sleep(sleep_time)


class TimeStrategy:
    def __init__(self, config):
        self.config = config
        self.lux = self.prev_lux = None

    def calculate(self):
        """
        we take current time (say 11:10am), convert to seconds (11*60*60 + 10*60 = 40200),
        and then because midday (43200s) is 100% lux and midnight (0s) is 0% lux,
        change of 1% of lux is (43200 / 100 = 432),
        current time 11am should be (100 - (43200 - 40200) / 432) = 93% of lux
        """
        midday_in_seconds = 43200
        utcnow = datetime.utcnow()
        midnight_utc = datetime.combine(utcnow.date(), time(0))
        now = utcnow - midnight_utc
        now_in_seconds = now.seconds
        # from midnigh to midday lux up
        if now_in_seconds > midday_in_seconds:
            lux = 100 - ((now_in_seconds * 100 / 43200) - 100)
        else:
            # after midday to midnigh lux down
            lux = now_in_seconds * 100 / 43200
        return int(lux)

    def loop(self):
        while True:
            self.lux = self.calculate()
            if self.lux != self.prev_lux:
                self.prev_lux = self.lux
                self.config.write_lux(self.lux)

            sleep_time = self.config.sleep_time

            if self.config.verbose:
                print("lux={} | waiting {} seconds...".format(self.lux, sleep_time))

            # wait
            sleep(sleep_time)


class FakeSensor:
    def __init__(self, strategy):
        self.config = config
        self.strategy = strategy
        self.config.create_fake_sensor()

    def run(self):
        self.strategy.loop()


class Config:
    def __init__(self):
        # test params
        try:
            opts, args = getopt.getopt(
                sys.argv[1:],
                "i:o:s:t:hv",
                ["input=", "output=", "sleep=", "strategy=", "help", "verbose"],
            )
        except getopt.GetoptError as err:
            print(err)
            self.usage()
            sys.exit(2)

        # default values
        self.input = INPUT
        self.sleep_time = SLEEP_TIME
        self.sleep_mode = SLEEP_MODE
        self.verbose = False
        self.strategy = STRATEGY
        self.output_basedir = (
            os.environ.get("WLUMA_LIGHT_SENSOR_BASE_PATH", FAKE_SENSOR)
            + "/light-sensor"
        )
        self.strategy = os.environ.get("FAKE_AMBIENT_LIGHT_SENSOR_STRATEGY", STRATEGY)

        # get params values
        for o, a in opts:
            if o in ("-v", "--verbose"):
                self.verbose = True
            elif o in ("-t", "--strategy"):
                self.strategy = a
            elif o in ("-s", "--sleep"):
                self.get_sleep_params(a)
            elif o in ("-i", "--input"):
                self.input = a
            elif o in ("-o", "--output"):
                self.output_basedir = a
            elif o in ("-h", "--help"):
                self.usage()
                sys.exit(0)
            else:
                assert False, "unhandled option, see --help"

        # create fake /sys dir
        Path(self.output_basedir).mkdir(parents=True, exist_ok=True)

        # lock
        if os.path.isfile(self.lockfile()):
            print("{} is already running!".format(os.path.basename(__file__)))
            sys.exit(2)

        # on exit do
        signal.signal(signal.SIGTERM, self.exit_handler)
        signal.signal(signal.SIGINT, self.exit_handler)

        Path(self.lockfile()).touch()

    def lockfile(self):
        return self.output_basedir + "/" + LOCKFILE

    def cleanup(self):
        os.remove(self.lockfile())

    def exit_handler(self, signal, frame):
        print("Receive signal {}, shutdown fake sensor...".format(signal))
        self.cleanup()
        sys.exit(0)

    def create_fake_sensor(self):
        als_raw = self.output_basedir + "/in_illuminance_raw"
        als_name = self.output_basedir + "/name"

        if not os.path.isfile(als_name):
            name = open(als_name, "w")
            name.write("als")
            name.flush()

        if self.verbose:
            print("input: {}, output: {}".format(self.input, als_raw))

        self.sensor = open(als_raw, "w+")

    def write_lux(self, lux):
        # write sensor value
        self.sensor.seek(0)
        self.sensor.truncate()
        self.sensor.write(str(lux))
        self.sensor.flush()
        os.fsync(self.sensor)

    def get_sleep_params(self, arg):
        if arg == "periods":
            self.sleep_mode = "periods"
            self.sleep_time = self.get_sleep_by_periods()
        elif arg == "lux":
            self.sleep_mode = "lux"
        else:
            try:
                self.sleep_time = int(arg)
                self.sleep_mode = "fixed"
            except:
                print(
                    "sleep must be an int or 'lux' or 'periods', default to {} seconds.".format(
                        SLEEP_TIME
                    )
                )
                self.sleep_time = int(SLEEP_TIME)

    def get_sleep_by_periods(self):
        hour = datetime.now().hour
        sleep_time = 30
        for p in SLEEP_PER_PERIODS:
            for r in SLEEP_PER_PERIODS[p]:
                if hour in range(r[0], r[1]):
                    sleep_time = p
                    break
        return int(sleep_time)

    def usage(self):
        print(
            """{} [--input=/dev/video0] [--output=/tmp/fake_light_sensor]
               [--sleep=10/periods] [--strategy=webcam/time] [--verbose]\n""".format(
                os.path.basename(__file__)
            )
        )

        print("env FAKE_AMBIENT_LIGHT_SENSOR_STRATEGY can be use for 'strategy'")


if __name__ == "__main__":

    try:
        config = Config()
        if config.strategy == "time":
            strategy = TimeStrategy(config)
        elif config.strategy == "webcam":
            from PIL import Image, ImageStat

            strategy = WebcamStrategy(config)
        else:
            config.usage()

        fals = FakeSensor(strategy)
        fals.run()

    except Exception as e:
        print("Got exception, aborting: ", e)
        config.cleanup()
        sys.exit(3)
