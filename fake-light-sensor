#!/usr/bin/env python3

import getopt
import math
import os
import os.path
import subprocess
import sys
import tempfile
import signal
import datetime
from pathlib import Path
from time import sleep

FAKE_SENSOR = "/tmp/fake-devices"
INPUT = "/dev/video0"
LOCKFILE = os.environ.get("XDG_RUNTIME_DIR", "/tmp") + "/fake-light-sensor.lock"
SLEEP_TIME = 30
MODE = "webcam"

LUX_PER_PERIODS = {
    0: [[0, 3]],
    25: [[3, 6]],
    50: [[6, 9]],
    75: [[9, 11], [13, 23]],
    100: [[12, 12]],
}

SLEEP_PER_PERIODS = {
    300: [[0, 6], [20, 23]],
    15: [[12, 15]],
}

# Magic to lux from image
def get_lightness(screenshot_cmd):
    f, path = tempfile.mkstemp()
    os.close(f)
    os.remove(path)

    path += ".jpg"
    try:
        subprocess.run([*screenshot_cmd, path], check=True)
    except FileNotFoundError as e:
        raise ("The binary is not found?\n{}".format(e))
        sys.exit(1)

    result = None
    with Image.open(path) as im:
        stat = ImageStat.Stat(im)
        r, g, b = stat.rms
        result = math.sqrt(0.241 * (r ** 2) + 0.691 * (g ** 2) + 0.068 * (b ** 2))

    os.remove(path)
    return int(100 * (result / 255))


def get_lux_by_time(hour):
    for p in LUX_PER_PERIODS:
        for r in LUX_PER_PERIODS[p]:
            if hour in range(r[0], r[1]):
                return int(p)


def get_sleep_by_periods(hour):
    sleep_time = 30
    for p in SLEEP_PER_PERIODS:
        for r in SLEEP_PER_PERIODS[p]:
            if hour in range(r[0], r[1]):
                sleep_time = p
                break
    return int(sleep_time)


# Usage
def usage():
    print(
        "{} [--input=/dev/video0] [--output=/tmp/fake_light_sensor] [--sleep=10/periods] [--mode=webcam/time] [--verbose]".format(
            os.path.basename(__file__)
        )
    )


# On Exit Handler
def exit_handler(signal, frame):
    print("Receive signal {}, shutdown fake sensor...".format(signal))
    os.remove(LOCKFILE)
    sys.exit(0)


class FakeSensor:
    def __init__(self):
        # test params
        try:
            opts, args = getopt.getopt(
                sys.argv[1:],
                "i:o:s:m:hv",
                ["help", "input=", "output=", "sleep=", "mode=", "verbose"],
            )
        except getopt.GetoptError as err:
            print(err)
            usage()
            sys.exit(2)

        # default values
        self.input = INPUT
        self.output_basedir = FAKE_SENSOR
        self.lux = self.prev_lux = 0
        self.sleep_time = SLEEP_TIME
        self.sleep_mode = False
        self.sleep_multiplicator = 1
        self.verbose = False
        self.mode = MODE
        self.output_basedir = (
            os.environ.get("WLUMA_LIGHT_SENSOR_BASE_PATH", FAKE_SENSOR)
            + "/light-sensor"
        )

        # get params values
        for o, a in opts:
            if o in ("-v", "--verbose"):
                self.verbose = True
            elif o in ("-m", "--mode"):
                self.mode = a
            elif o in ("-s", "--sleep"):
                if a == "periods":
                    self.sleep_mode = "periods"
                    self.sleep_time = get_sleep_by_periods(datetime.datetime.now().hour)
                else:
                    self.sleep_time = a
            elif o in ("-i", "--input"):
                self.input = a
            elif o in ("-o", "--output"):
                self.output_basedir = a
            elif o in ("-h", "--help"):
                usage()
                sys.exit()
            else:
                assert False, "unhandled option, see --help"

        if self.mode == "periods":
            self.input = LUX_PER_PERIODS

        # on exit do
        signal.signal(signal.SIGTERM, exit_handler)
        signal.signal(signal.SIGINT, exit_handler)

        # lock
        if os.path.isfile(LOCKFILE):
            print("{} already running!".format(os.path.basename(__file__)))
            sys.exit(2)
        Path(LOCKFILE).touch()

        self.capture_command = [
            "ffmpeg",
            "-hide_banner",
            "-loglevel",
            "panic",
            "-i",
            self.input,
            "-vframes",
            "1",
        ]

        # create fake sys tree
        self.create_fake_sensor()

    def create_fake_sensor(self):
        als_raw = self.output_basedir + "/in_illuminance_raw"
        als_name = self.output_basedir + "/name"

        # create fake /sys dir
        Path(self.output_basedir).mkdir(parents=True, exist_ok=True)
        if not os.path.isfile(als_name):
            name = open(als_name, "w")
            name.write("als")
            name.flush()

        if self.verbose:
            print("input: {}, output: {}".format(self.input, als_raw))

        self.sensor = open(als_raw, "w+")

    def write_lux(self):
        # write sensor value
        self.sensor.seek(0)
        self.sensor.truncate()
        self.sensor.write(str(self.lux))
        self.sensor.flush()
        os.fsync(self.sensor)

    def webcam_loop(self):
        while True:
            # get sensor value
            try:
                self.lux = get_lightness(self.capture_command)
            except subprocess.CalledProcessError as e:
                raise ("Can't get lux, bad input device?\n{}".format(e))
                sys.exit(1)

            if self.lux != self.prev_lux:
                self.prev_lux = self.lux
                self.write_lux()

            if self.sleep_mode and self.sleep_mode == "periods":
                sleep_time = get_sleep_by_periods(datetime.datetime.now().hour)
            else:
                # less refresh in the dark
                sleep_time = (
                    (self.sleep_time * 2) if self.lux <= 10 else self.sleep_time
                )

                # more refresh if very bright
                sleep_time = (
                    (self.sleep_time * 0.5) if self.lux >= 80 else self.sleep_time
                )

            if self.verbose:
                print("lux={} | waiting {} seconds...".format(self.lux, sleep_time))

            # wait
            sleep(sleep_time)

    def period_loop(self):
        while True:
            hour = datetime.datetime.now().hour
            self.lux = get_lux_by_time(hour)
            if self.lux != self.prev_lux:
                self.prev_lux = self.lux
                self.write_lux()

            sleep_time = 60
            if self.verbose:
                print("lux={} | waiting {} seconds...".format(self.lux, sleep_time))

            # wait
            sleep(sleep_time)


if __name__ == "__main__":
    fals = FakeSensor()
    if fals.mode == "webcam":
        from PIL import Image, ImageStat

    if fals.mode == "periods":
        print("Time period mode will be use")
        fals.period_loop()
    elif fals.mode == "webcam":
        print("Webcam mode will be use")
        fals.webcam_loop()
